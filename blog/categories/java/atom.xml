<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Nadia Humbert-Labeaumaz]]></title>
  <link href="https://nphumbert.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="https://nphumbert.github.io/"/>
  <updated>2016-05-25T01:00:16+02:00</updated>
  <id>https://nphumbert.github.io/</id>
  <author>
    <name><![CDATA[Nadia Humbert-Labeaumaz]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Pourquoi ne pas utiliser l'héritage pour éviter la duplication de code ?]]></title>
    <link href="https://nphumbert.github.io/blog/2016/01/24/heritage-duplication-code/"/>
    <updated>2016-01-24T11:38:41+01:00</updated>
    <id>https://nphumbert.github.io/blog/2016/01/24/heritage-duplication-code</id>
    <content type="html"><![CDATA[<p>L'héritage est une composante très importante des langages orientés objet tels que Java. Cependant, il doit être utilisé à bon escient afin de respecter les bonnes pratiques de programmation.</p>

<p>Il m'est arrivé de rencontrer des cas où l'héritage était utilisé afin de ne pas dupliquer du code. Le but de cet article est d'illustrer une telle utilisation, d'analyser ses inconvénients et de montrer une manière possible de la corriger.</p>

<!-- more -->


<h2>Contexte</h2>

<p>Un projet d'illustration a été créé afin de servir de support pour cet article. Il est disponible sur <a href="https://github.com/nphumbert/demo-inappropriate-inheritance">GitHub</a>. Ce projet contient deux branches :</p>

<ul>
<li><code>inappropriate-inheritance</code> : contient l'utilisation inappropriée de l'héritage.</li>
<li><code>dependency</code> : contient une proposition de correction en utilisant une dépendance.</li>
</ul>


<p>Il s'agit de deux <em>controllers</em> Spring MVC qui doivent hasher un texte. Dans le cas de l'utilisation inappropriée de l'héritage, le code d'un des <em>controllers</em> est le suivant :</p>

<pre><code class="java">@RestController
public class ProfileController extends BaseController {

    @RequestMapping(value = "/profile", method = RequestMethod.GET)
    public String profile() {
        return "profile: " + hash("profile");
    }
}
</code></pre>

<p>Ce <em>controller</em> hérite d'une classe commune qui contient la méthode <code>hash</code> :</p>

<pre><code class="java">public abstract class BaseController {
    protected String hash(String value) {
        // ...
    }
}
</code></pre>

<h2>Pourquoi n'est-il pas correct d'utiliser l'héritage ici ?</h2>

<h3>Non respect de la programmation orientée objet (POO)</h3>

<p>Dans ce code, la mécanique de la POO est respectée mais pas sa sémantique. En effet, la classe <code>BaseController</code> n'a pas de raison d'être. Elle ne correspond à aucun concept et ne sert qu'à contenir du code partagé entre les <em>controllers</em>. Ce genre de classe possède souvent un nom flou et générique, ce qui est un signe que le concept associé est mal défini, voire inexistant.</p>

<h3>Difficulté à tester</h3>

<p>La capacité du code à être testé n'est pas une fin en soi. Cependant, un code difficile à tester est un <em>smell</em> qui indique le plus souvent un problème de conception.</p>

<p>Ici, il est obligatoire de passer par un <em>set up</em> assez lourd pour tester en isolation le <em>controller</em>. Une classe privée héritant du <em>controller</em> est créée afin de surcharger la méthode <code>hash</code> et de fixer la valeur de retour. Les tests portent donc sur cette classe au lieu de porter sur le <em>controller</em> initial.</p>

<pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = InappropriateInheritanceApplication.class)
@WebAppConfiguration
public class ProfileControllerTest {

    public static final String HASH = "hash";

    private class TestableProfileController extends ProfileController {

        @Override
        protected String hash(String value) {
            return HASH;
        }
    }

    private MockMvc mockMvc;

    @Before
    public void setUp() {
        ProfileController controller = new TestableProfileController();
        this.mockMvc = MockMvcBuilders.standaloneSetup(controller).build();
    }

    @Test
    public void should_get_hash_when_get_profile() throws Exception {
        // when
        String contentAsString = mockMvc.perform(get("/profile"))
                .andExpect(status().isOk())
                .andReturn().getResponse().getContentAsString();

        // then
        assertThat(contentAsString, is("profile: " + HASH));
    }
}
</code></pre>

<p>La complexité du <em>set up</em> est bien trop importante par rapport au code à tester qui est relativement simple.</p>

<h3>Fort couplage</h3>

<p>L'héritage introduit un fort couplage entre les classes. En effet, tous les <em>controllers</em> doivent hériter de <code>BaseController</code> pour bénéficier de la méthode <code>hash</code>. Ceci implique qu'ils doivent avoir accès à cette classe (soit être dans le même projet, soit avoir une dépendance vers sa librairie).</p>

<p>De plus, l'héritage multiple étant interdit en Java, les <em>controllers</em> ne peuvent pas hériter d'une autre classe qui serait appropriée.</p>

<p>Finalement, si une autre classe avait besoin de la méthode <code>hash</code>, elle devrait forcément hériter de <code>BaseController</code> (ce qui n'a pas de sens s'il ne s'agit pas d'un <em>controller</em>) ou alors dupliquer le code. Ce problème met en évidence le fait que la notion de hashage n'a aucun rapport avec la notion de <em>controller</em>.</p>

<h3>Difficulté à maintenir</h3>

<p>Le couplage fort décrit précédemment rend le code difficile à maintenir. Un changement du besoin entraînerait une modification du code à un endroit où on ne s'y attend pas. Par ailleurs, il pourrait y avoir des effets de bord inattendus sur le reste du code.</p>

<h2>Comment peut-on corriger ce code ?</h2>

<p>La solution proposée pour corriger ce code est d'extraire la méthode de <code>hash</code> dans une dépendance qui sera injectée dans les <em>controllers</em>.</p>

<p>Tout d'abord, une interface <code>HashProvider</code> est créée et implémentée.</p>

<pre><code class="java">public interface HashProvider {
    String hash(String text);
}
</code></pre>

<pre><code class="java">@Component
public class Sha256HashProvider implements HashProvider {

    @Override
    public String hash(String value) {
        // ...
    }
}
</code></pre>

<p>Cette implémentation peut alors être injectée dans le <em>controller</em> afin d'être utilisée.</p>

<pre><code class="java">@RestController
public class ProfileController {

    private final HashProvider hashProvider;

    @Autowired
    public ProfileController(HashProvider hashProvider) {
        this.hashProvider = hashProvider;
    }

    @RequestMapping(value = "/profile", method = RequestMethod.GET)
    public String profile() {
        return "profile: " + hashProvider.hash("profile");
    }
}
</code></pre>

<p>Le <em>set up</em> de test de ce <em>controller</em> s'en trouve simplifié car il n'y a plus qu'à <em>mocker</em> l'interface.</p>

<pre><code class="java">@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = InappropriateInheritanceApplication.class)
@WebAppConfiguration
public class ProfileControllerTest {

    private MockMvc mockMvc;
    private HashProvider hashProvider;

    @Before
    public void setUp() {
        hashProvider = mock(HashProvider.class);
        ProfileController controller = new ProfileController(hashProvider);
        this.mockMvc = MockMvcBuilders.standaloneSetup(controller).build();
    }

    @Test
    public void should_get_hash_when_get_profile() throws Exception {
        // given
        when(hashProvider.hash("profile")).thenReturn("hash");

        // when
        String contentAsString = mockMvc.perform(get("/profile"))
                .andExpect(status().isOk())
                .andReturn().getResponse().getContentAsString();

        // then
        assertThat(contentAsString, is("profile: hash"));
    }
}
</code></pre>

<p>Finalement, la logique de hashage est totalement découplée de celle du <em>controller</em>. Ceci rend le code plus simple à maintenir car si le besoin change, il suffit de modifier l'implémentation de <code>HashProvider</code> ou d'en ajouter une nouvelle. Ainsi, le comportement du <em>controller</em> est modifié sans que son code ne change.</p>

<h2>Conclusion</h2>

<p>Il est nécessaire de faire attention à ne pas abuser de l'héritage. Dans cet article, il a été montré qu'il n'est pas approprié pour éviter la duplication de code. Dans ce cas, il est préférable d'utiliser une interface dont une implémentation sera injectée. Ceci a pour principal avantage de rendre le code plus simple et facile à maintenir.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Testing Spring MVC Controllers]]></title>
    <link href="https://nphumbert.github.io/blog/2015/10/31/testing-spring-mvc-controllers/"/>
    <updated>2015-10-31T12:54:08+01:00</updated>
    <id>https://nphumbert.github.io/blog/2015/10/31/testing-spring-mvc-controllers</id>
    <content type="html"><![CDATA[<p>Since Spring 3.2 (January, 2013), it is possible to test Spring MVC controllers without an external framework.
The goal of this article is to show how to test Spring MVC controllers using only Spring testing capabilities.</p>

<!-- more -->


<p>To do so, a very simple Spring Boot project will be used as a support. You can find it on <a href="https://github.com/nphumbert/demo-test-spring-mvc">GitHub</a>. The controller to test will first be introduced. Then, explanations will be given on how to test it.</p>

<h2>Controller</h2>

<p>The controller that will be tested is showed below. It permits to do a search in a fruit list.</p>

<pre><code class="java">@Controller
public class ApplicationController {

    @RequestMapping(value = "/fruits", method = RequestMethod.GET)
    public String getFruits(@RequestParam(value = "search", required = false) String search, final Model model) {
        model.addAttribute("fruitBowl", search(search));
        return "fruits";
    }

    private List&lt;String&gt; search(String search) {
        if (StringUtils.isEmpty(search)) {
            return fruitBowl();
        }

        return fruitBowl().stream()
                .filter(fruit -&gt; fruit.startsWith(search))
                .collect(toList());
    }

    private List&lt;String&gt; fruitBowl() {
        return asList("banana", "orange");
    }
}
</code></pre>

<h2>Test</h2>

<p>The test class must be annotated with the following annotations:</p>

<ul>
<li><code>@RunWith(SpringJUnit4ClassRunner.class)</code> to benefit from Spring features in JUnit tests.</li>
<li><code>@SpringApplicationConfiguration(classes = DemoTestSpringMvcApplication.class)</code> to specify the configuration class that will be used during the test.</li>
<li><code>@WebAppConfiguration</code> to indicate that the Spring application context that must be loaded is a <code>WebApplicationContext</code>.</li>
</ul>


<p>The entry point used to perform the tests is the class <code>MockMvc</code>. Thereafter, the usage of this class will be explained.</p>

<h3>Set up</h3>

<p>The set up of the <code>MockMvc</code> class can be done as follows:</p>

<pre><code class="java">@Before
public void setUp() {
    ApplicationController controller = new ApplicationController(); // 1
    this.mockMvc = MockMvcBuilders.standaloneSetup(controller).build(); // 2
}
</code></pre>

<p>First, the controller must be instantiated (<code>1</code>). Then, the mock is initialized using the static method <code>MockMvcBuilders.standaloneSetup()</code> (<code>2</code>). At this point, the mock is ready to test the controller.</p>

<h3>Perform</h3>

<p>The method <code>MockMvc.perform()</code> allows to simulate HTTP requests to the controller. For instance, a GET request is done as follows:</p>

<pre><code class="java">mockMvc.perform(
    get("/fruits") // 1
        .param("search", "ban") // 2
);
</code></pre>

<p>The class <code>MockMvcRequestBuilders</code> provides static methods, such as <code>get</code> or <code>post</code>, to simulate HTTP requests on a particular endpoint of the controller (<code>1</code>). HTTP parameters can be added fluently to the request (<code>2</code>).</p>

<p>Furthermore, other static methods are provided by the <code>MockMvcRequestBuilders</code> class:</p>

<ul>
<li>HTTP verbs like <code>delete</code>, <code>put</code> or <code>patch</code>.</li>
<li><code>fileUpload</code> to upload binary files.</li>
<li>Others (<a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/test/web/servlet/request/MockMvcRequestBuilders.html">documentation</a>).</li>
</ul>


<h3>Assert</h3>

<p>MockMvc permits to add assertions to the controller&rsquo;s response.</p>

<pre><code class="java">mockMvc.perform(get("/fruits")
    .param("search", "ban"))
    .andExpect(status().isOk()) // 1
    .andExpect(view().name("fruits")) // 2
    .andExpect(model().attribute("fruitBowl", contains("banana"))); // 3
</code></pre>

<p>Assertions are done with the <code>andExpect()</code> method. The class <code>MockMvcResultMatchers</code> provides static methods to do assertions on the HTTP status (<code>1</code>), the view asked by the controller (<code>2</code>) and on the model completed by the controller (<code>3</code>).</p>

<h2>Conclusion</h2>

<p>The Spring test framework is a very powerful, complete and simple way to test Spring MVC controllers. Its fluent API allows to write elegant and yet precise tests.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring Security et Spring Boot]]></title>
    <link href="https://nphumbert.github.io/blog/2015/06/21/spring-security-et-spring-boot/"/>
    <updated>2015-06-21T11:51:37+02:00</updated>
    <id>https://nphumbert.github.io/blog/2015/06/21/spring-security-et-spring-boot</id>
    <content type="html"><![CDATA[<p>Depuis Spring 3.1, il est possible de configurer Spring en Java.
La configuration Java de Spring Security est supportée depuis sa version 3.2 (<a href="http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#jc">source</a>).</p>

<p>L'objectif de cet article est de montrer comment configurer Spring Security en Java config, dans une application Spring Boot, avec une base de données qui contient les utilisateurs et leur mot de passe hashé. De plus, une authentification HTTP basic sera mise en place.</p>

<!-- more -->


<h2>Créer la classe de configuration</h2>

<p>La classe Java qui doit gérer la configuration doit être munie de l'annotation <code>@Configuration</code> définie par Spring. De plus, elle doit étendre la classe <code>WebSecurityConfigurerAdapter</code>. Spring Boot mettant en place une configuration par défaut, il faut donc finalement utiliser l'annotation <code>@Order</code> afin d'indiquer que la nouvelle configuration doit être utilisée.</p>

<pre><code class="java">@Configuration
@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

}
</code></pre>

<h2>Configurer Spring Security pour utiliser une base de données</h2>

<p>Pour indiquer à Spring la méthode d'authentification, il faut redéfinir la méthode <code>configure(AuthenticationManagerBuilder)</code>. Spring Security offre une API <em>fluent</em> pour configurer une authentification à partir de l'objet <code>AuthenticationManagerBuilder</code>.</p>

<p>Le code ci-dessous permet de configurer l'authentification en utilisant une base de données.</p>

<pre><code class="java">@Configuration
@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Autowired
    private DataSource dataSource; // 3

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.jdbcAuthentication() // 1
                .passwordEncoder(new ShaPasswordEncoder(256)) // 6
                .dataSource(dataSource) // 2
                .usersByUsernameQuery("SELECT login, password, active FROM user WHERE login=?") // 4
                .authoritiesByUsernameQuery("SELECT login, role FROM user WHERE login=?"); // 5
    }
}
</code></pre>

<p>Dans le cadre de cet article, il s'agit d'une authentification JDBC (<code>1</code>). La base de données à laquelle Spring doit accéder est accessible via une <code>dataSource</code> (<code>2</code>). Elle a été configurée dans l'application (typiquement dans <code>application.properties</code>) et peut donc être directement injectée par Spring grâce à l'annotation <code>@Autowired</code> (<code>3</code>).</p>

<p>La requête pour récupérer un utilisateur à partir de son login est fournie via la méthode <code>usersByUsernameQuery</code> (<code>4</code>) et celle pour récupérer les rôles d'un utilisateur à partir de son login via la méthode <code>authoritiesByUsernameQuery</code> (<code>5</code>). Un utilisateur est caractérisé par un login, un mot de passe et un booléen indiquant s'il est actif. Un rôle est une chaîne de caractères qui correspondra à un profil ayant un ensemble de droits.</p>

<p>Finalement, il est indiqué que les mots de passe dans la base sont hashés à l'aide de l'agorithme SHA-256 (<code>6</code>).</p>

<h2>Configuration de l'authentification HTTP basic</h2>

<p>La méthode d'authentification <a href="https://fr.wikipedia.org/wiki/Authentification_HTTP#M.C3.A9thode_.C2.AB_Basic_.C2.BB">HTTP basic</a> est une méthode d'authentification simple en HTTP et sera utilisée dans cet article.
Cette méthode est indiquée en surchargeant la méthode <code>configure(HTTPSecurity)</code>. De même que dans la section précédente, Spring Security offre une API <em>fluent</em> pour configurer une authentification HTTP à partir de l'objet <code>HTTPSecurity</code>.</p>

<p>Le code ci-dessous permet de configurer l'authentification HTTP basic.</p>

<pre><code class="java">@Override
protected void configure(HttpSecurity http) throws Exception {
    http.httpBasic() // 1
            .and()
                .authorizeRequests()
                    .antMatchers("/", "/css/**", "/js/**").permitAll() // 2
                    .anyRequest().authenticated() // 3
            .and()
                .formLogin()
                   .loginPage("/login").permitAll() // 4
            .and()
               .logout()
                   .logoutUrl("/logout") // 5
                   .logoutSuccessUrl("/"); // 6
}
</code></pre>

<p>La méthode d'authentification HTTP est précisée avec la méthode <code>httpBasic</code> (<code>1</code>). La racine, les fichiers CSS et javascript sont accessibles à tout le monde (<code>2</code>) tandis que toutes les autres requêtes nécessitent d'être authentifié (<code>3</code>).</p>

<p>L'URL de login est spécifiée via la méthode <code>loginPage</code> (<code>4</code>) et celle de logout via la méthode <code>logoutUrl</code> (<code>5</code>). Après la déconnexion, l'utilisateur est redirigé vers la racine (<code>6</code>).</p>

<p>Le code suivant illustre un formulaire de login et un formulaire de logout.</p>

<p>```html</p>

<!-- Formulaire de login -->


<p><form action="/login" method="post">
    <input type="text" name="username" />
    <input type="password" name="password" />
    <button type="submit">Login</button>
</form></p>

<!-- Formulaire de logout -->


<p><form action="/logout" method="post">
    <button type="submit">Logout</button>
</form>
```</p>

<h2>Conclusion</h2>

<p>La configuration de Spring Security en Java config est relativement simple et directe. Elle permet de contrôler et de centraliser les accès à toutes les URL de l'application. De plus, il est possible de définir très simplement les URL de login et de logout, Spring Security se chargeant des traitements des requêtes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Injections de dépendances avec Spring]]></title>
    <link href="https://nphumbert.github.io/blog/2015/06/14/injections-de-dependances-avec-spring/"/>
    <updated>2015-06-14T08:35:20+02:00</updated>
    <id>https://nphumbert.github.io/blog/2015/06/14/injections-de-dependances-avec-spring</id>
    <content type="html"><![CDATA[<p>Il existe plusieurs méthodes pour injecter une dépendance dans un objet Java :</p>

<ul>
<li>Injection sur un setter</li>
<li>Injection sur le constructeur</li>
<li>Injection directe sur la déclaration de l'attribut</li>
</ul>


<p>Cet article a pour objectif de définir ces différentes méthodes, de décrire leurs avantages et inconvénients et indiquer leurs cas d'utilisation.</p>

<!-- more -->


<p>Dans la plupart des applications Java d'entreprise, il y a des services ayant besoin de DAO pour accéder à la base de données. Le code suivant est une illustration de ce cas :</p>

<pre><code class="java">public class UserServiceImpl implements UserService {

   private UserDao userDao;

   @Override
   public User save(String name) {

      User user = new User(name);

      // NullPointerException car userDao n'est pas injecté.
      return userDao.save(user);
   }
}
</code></pre>

<p>Dans le cadre de cet article, l'annotation <code>@Autowired</code> de Spring sera utilisée pour injecter <code>userDao</code> dans le service.</p>

<h2>Injection sur un setter</h2>

<p>Il est possible de créer un setter et de l'annoter avec <code>@Autowired</code>. Spring va alors utiliser ce setter pour injecter <code>userDao</code> dans le service.</p>

<pre><code class="java">public class UserServiceImpl implements UserService {

   private UserDao userDao;

   @Autowired
   public void setUserDao(UserDao userDao) {
      this.userDao = userDao;
   }

   @Override
   public User save(String name) {

      User user = new User(name);

      // userDao est injecté via le setter annoté.
      return userDao.save(user);
   }
}
</code></pre>

<p>Cette méthode a pour avantage de rendre le <code>userDao</code> facilement injectable dans un test unitaire sans avoir à utiliser de framework particulier. Comme montré dans l'exemple ci-après :</p>

<pre><code class="java">public class UserServiceTest {

   @Test
   public void test_save() {

      // given
      String name = "Martin";
      UserService userService = new UserServiceImpl();
      userService.setUserDao(new FakeUserDaoImpl());

      // when
      User user = userService.save(name);

      // then
      assertThat(user.getName()).isEqualTo(name);

   }

   private class FakeUserDaoImpl implements UserDao {

      @Override
      public User save(User user) {
         return user;
      }
   }

}
</code></pre>

<p>Cependant, elle a pour inconvénient de rendre l'attribut <code>userDao</code> du service modifiable par tous les objets qui disposent d'une instance du service (ils peuvent donc même le rendre <code>null</code>).</p>

<h2>Injection sur le constructeur</h2>

<p>Dans cette méthode d'injection, le <code>userDao</code> est injecté dans le service via son constructeur annoté avec <code>@Autowired</code>.</p>

<pre><code class="java">public class UserServiceImpl implements UserService {

   private final UserDao userDao;

   @Autowired
   public UserServiceImpl(UserDao userDao) {
      this.userDao = userDao;
   }

   @Override
   public User save(String name) {

      User user = new User(name);

      // userDao est injecté via le constructeur annoté.
      return userDao.save(user);
   }
}
</code></pre>

<p>Comme la méthode d'injection à l'aide du setter, celle-ci permet de rendre le <code>userDao</code> facilement injectable dans un test unitaire.</p>

<pre><code class="java">public class UserServiceTest {

   @Test
   public void test_save() {

      // given
      String name = "Martin";
      UserService userService = new UserServiceImpl(new FakeUserDaoImpl());

      // when
      User user = userService.save(name);

      // then
      assertThat(user.getName()).isEqualTo(name);

   }

   private class FakeUserDaoImpl implements UserDao {

      @Override
      public User save(User user) {
         return user;
      }
   }

}
</code></pre>

<p>De plus, elle permet également d'assurer que le <code>userDao</code> ne sera jamais modifié. Il suffirait donc de mettre un contrôle de nullité dans le constructeur pour certifier qu'il ne sera jamais <code>null</code>.</p>

<p>Cependant, elle a pour inconvénient d'imposer la création de la dépendance dès l'instanciation du service même si elle n'est pas nécessaire.</p>

<h2>Injection sur la déclaration de l'attribut</h2>

<p>Cette méthode consiste à ajouter l'annotation <code>@Autowired</code> directement sur la déclaration de l'attribut.</p>

<pre><code class="java">public class UserServiceImpl implements UserService {

   @Autowired
   private UserDao userDao;

   @Override
   public User save(String name) {

      User user = new User(name);

      // userDao est injecté via l'annotation @Autowired.
      return userDao.save(user);
   }
}
</code></pre>

<p>Cette manière d'injecter a l'avantage d'être simple à utiliser.</p>

<p>Néanmoins, elle n'est pas conseillée car elle force à employer la réfléxion, ce qui la rend notamment plus compliquée à tester (utilisation obligatoire d'un framework de test).</p>

<pre><code class="java">public class UserServiceTest {

   @Test
   public void test_save() {

      // given
      String name = "Martin";
      UserService userService = new UserServiceImpl();
      UserDao fakeUserDao = new FakeUserDaoImpl();

      // Utilisation de la classe ReflectionTestUtils de Spring.
      ReflectionTestUtils.setField(userService, "userDao", fakeUserDao);

      // when
      User user = userService.save(name);

      // then
      assertThat(user.getName()).isEqualTo(name);

   }

   private class FakeUserDaoImpl implements UserDao {

      @Override
      public User save(User user) {
         return user;
      }
   }

}
</code></pre>

<p>De plus, elle rompt le principe de la programmation orientée objet qui stipule que les objets sont responsables de leurs attributs privés. En effet, l'attribut privé est ici manipulé directement par Spring ou le framework de test choisi.</p>

<h2>Conclusion</h2>

<p>L'injection d'un attribut d'un objet peut se faire de différentes manières.
L'injection par setter a pour avantage de rendre le code facilement testable. L'injection par constructeur a, en plus, l'avantage de pouvoir contrôler la nullité de l'attribut. Elle est donc conseilée pour les attributs obligatoires. Finalement, l'injection sur la déclaration de l'attribut est déconseilée car elle rend le code moins facilement testable et crée des dépendances cachées.</p>

<p>La testabilité du code est importante. En effet, un code non testable est signe d'un code qui sera difficile à comprendre et à maintenir.</p>
]]></content>
  </entry>
  
</feed>
