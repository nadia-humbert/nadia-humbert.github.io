<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Nadia Humbert-Labeaumaz]]></title>
  <link href="http://nphumbert.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://nphumbert.github.io/"/>
  <updated>2016-01-18T22:25:57+01:00</updated>
  <id>http://nphumbert.github.io/</id>
  <author>
    <name><![CDATA[Nadia Humbert-Labeaumaz]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Testing Spring MVC controllers]]></title>
    <link href="http://nphumbert.github.io/blog/2015/10/31/testing-spring-mvc-controllers/"/>
    <updated>2015-10-31T12:54:08+01:00</updated>
    <id>http://nphumbert.github.io/blog/2015/10/31/testing-spring-mvc-controllers</id>
    <content type="html"><![CDATA[<p>Since Spring 3.2 (January, 2013), it is possible to test Spring MVC controllers without an external framework.
The goal of this article is to show how to test Spring MVC controllers using only Spring testing capabilities.</p>

<!-- more -->


<p>To do so, a very simple Spring Boot project will be used as a support. You can find it on <a href="https://github.com/nphumbert/demo-test-spring-mvc">GitHub</a>. The controller to test will first be introduced. Then, explanations will be given on how to test it.</p>

<h2>Controller</h2>

<p>The controller that will be tested is showed below. It permits to do a search in a fruit list.</p>

<pre><code class="java">@Controller
public class ApplicationController {

    @RequestMapping(value = "/fruits", method = RequestMethod.GET)
    public String getFruits(@RequestParam(value = "search", required = false) String search, final Model model) {
        model.addAttribute("fruitBowl", search(search));
        return "fruits";
    }

    private List&lt;String&gt; search(String search) {
        if (StringUtils.isEmpty(search)) {
            return fruitBowl();
        }

        return fruitBowl().stream()
                .filter(fruit -&gt; fruit.startsWith(search))
                .collect(toList());
    }

    private List&lt;String&gt; fruitBowl() {
        return asList("banana", "orange");
    }
}
</code></pre>

<h2>Test</h2>

<p>The test class must be annotated with the following annotations:</p>

<ul>
<li><code>@RunWith(SpringJUnit4ClassRunner.class)</code> to benefit from Spring features in JUnit tests.</li>
<li><code>@SpringApplicationConfiguration(classes = DemoTestSpringMvcApplication.class)</code> to specify the configuration class that will be used during the test.</li>
<li><code>@WebAppConfiguration</code> to indicate that the Spring application context that must be loaded is a <code>WebApplicationContext</code>.</li>
</ul>


<p>The entry point used to perform the tests is the class <code>MockMvc</code>. Thereafter, the usage of this class will be explained.</p>

<h3>Set up</h3>

<p>The set up of the <code>MockMvc</code> class can be done as follows:</p>

<pre><code class="java">@Before
public void setUp() {
    ApplicationController controller = new ApplicationController(); // 1
    this.mockMvc = MockMvcBuilders.standaloneSetup(controller).build(); // 2
}
</code></pre>

<p>First, the controller must be instantiated (<code>1</code>). Then, the mock is initialized using the static method <code>MockMvcBuilders.standaloneSetup()</code> (<code>2</code>). At this point, the mock is ready to test the controller.</p>

<h3>Perform</h3>

<p>The method <code>MockMvc.perform()</code> allows to simulate HTTP requests to the controller. For instance, a GET request is done as follows:</p>

<pre><code class="java">mockMvc.perform(
    get("/fruits") // 1
        .param("search", "ban") // 2
);
</code></pre>

<p>The class <code>MockMvcRequestBuilders</code> provides static methods, such as <code>get</code> or <code>post</code>, to simulate HTTP requests on a particular endpoint of the controller (<code>1</code>). HTTP parameters can be added fluently to the request (<code>2</code>).</p>

<p>Furthermore, other static methods are provided by the <code>MockMvcRequestBuilders</code> class:</p>

<ul>
<li>HTTP verbs like <code>delete</code>, <code>put</code> or <code>patch</code>.</li>
<li><code>fileUpload</code> to upload binary files.</li>
<li>Others (<a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/test/web/servlet/request/MockMvcRequestBuilders.html">documentation</a>).</li>
</ul>


<h3>Assert</h3>

<p>MockMvc permits to add assertions to the controller&rsquo;s response.</p>

<pre><code class="java">mockMvc.perform(get("/fruits")
    .param("search", "ban"))
    .andExpect(status().isOk()) // 1
    .andExpect(view().name("fruits")) // 2
    .andExpect(model().attribute("fruitBowl", contains("banana"))); // 3
</code></pre>

<p>Assertions are done with the <code>andExpect()</code> method. The class <code>MockMvcResultMatchers</code> provides static methods to do assertions on the HTTP status (<code>1</code>), the view asked by the controller (<code>2</code>) and on the model completed by the controller (<code>3</code>).</p>

<h2>Conclusion</h2>

<p>The Spring test framework is a very powerful, complete and simple way to test Spring MVC controllers. Its fluent API allows to write elegant and yet precise tests.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring Security et Spring Boot]]></title>
    <link href="http://nphumbert.github.io/blog/2015/06/21/spring-security-et-spring-boot/"/>
    <updated>2015-06-21T11:51:37+02:00</updated>
    <id>http://nphumbert.github.io/blog/2015/06/21/spring-security-et-spring-boot</id>
    <content type="html"><![CDATA[<p>Depuis Spring 3.1, il est possible de configurer Spring en Java.
La configuration Java de Spring Security est supportée depuis sa version 3.2 (<a href="http://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#jc">source</a>).</p>

<p>L'objectif de cet article est de montrer comment configurer Spring Security en Java config, dans une application Spring Boot, avec une base de données qui contient les utilisateurs et leur mot de passe hashé. De plus, une authentification HTTP basic sera mise en place.</p>

<!-- more -->


<h2>Créer la classe de configuration</h2>

<p>La classe Java qui doit gérer la configuration doit être munie de l'annotation <code>@Configuration</code> définie par Spring. De plus, elle doit étendre la classe <code>WebSecurityConfigurerAdapter</code>. Spring Boot mettant en place une configuration par défaut, il faut donc finalement utiliser l'annotation <code>@Order</code> afin d'indiquer que la nouvelle configuration doit être utilisée.</p>

<pre><code class="java">@Configuration
@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

}
</code></pre>

<h2>Configurer Spring Security pour utiliser une base de données</h2>

<p>Pour indiquer à Spring la méthode d'authentification, il faut redéfinir la méthode <code>configure(AuthenticationManagerBuilder)</code>. Spring Security offre une API <em>fluent</em> pour configurer une authentification à partir de l'objet <code>AuthenticationManagerBuilder</code>.</p>

<p>Le code ci-dessous permet de configurer l'authentification en utilisant une base de données.</p>

<pre><code class="java">@Configuration
@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Autowired
    private DataSource dataSource; // 3

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.jdbcAuthentication() // 1
                .passwordEncoder(new ShaPasswordEncoder(256)) // 6
                .dataSource(dataSource) // 2
                .usersByUsernameQuery("SELECT login, password, active FROM user WHERE login=?") // 4
                .authoritiesByUsernameQuery("SELECT login, role FROM user WHERE login=?"); // 5
    }
}
</code></pre>

<p>Dans le cadre de cet article, il s'agit d'une authentification JDBC (<code>1</code>). La base de données à laquelle Spring doit accéder est accessible via une <code>dataSource</code> (<code>2</code>). Elle a été configurée dans l'application (typiquement dans <code>application.properties</code>) et peut donc être directement injectée par Spring grâce à l'annotation <code>@Autowired</code> (<code>3</code>).</p>

<p>La requête pour récupérer un utilisateur à partir de son login est fournie via la méthode <code>usersByUsernameQuery</code> (<code>4</code>) et celle pour récupérer les rôles d'un utilisateur à partir de son login via la méthode <code>authoritiesByUsernameQuery</code> (<code>5</code>). Un utilisateur est caractérisé par un login, un mot de passe et un booléen indiquant s'il est actif. Un rôle est une chaîne de caractères qui correspondra à un profil ayant un ensemble de droits.</p>

<p>Finalement, il est indiqué que les mots de passe dans la base sont hashés à l'aide de l'agorithme SHA-256 (<code>6</code>).</p>

<h2>Configuration de l'authentification HTTP basic</h2>

<p>La méthode d'authentification <a href="https://fr.wikipedia.org/wiki/Authentification_HTTP#M.C3.A9thode_.C2.AB_Basic_.C2.BB">HTTP basic</a> est une méthode d'authentification simple en HTTP et sera utilisée dans cet article.
Cette méthode est indiquée en surchargeant la méthode <code>configure(HTTPSecurity)</code>. De même que dans la section précédente, Spring Security offre une API <em>fluent</em> pour configurer une authentification HTTP à partir de l'objet <code>HTTPSecurity</code>.</p>

<p>Le code ci-dessous permet de configurer l'authentification HTTP basic.</p>

<pre><code class="java">@Override
protected void configure(HttpSecurity http) throws Exception {
    http.httpBasic() // 1
            .and()
                .authorizeRequests()
                    .antMatchers("/", "/css/**", "/js/**").permitAll() // 2
                    .anyRequest().authenticated() // 3
            .and()
                .formLogin()
                   .loginPage("/login").permitAll() // 4
            .and()
               .logout()
                   .logoutUrl("/logout") // 5
                   .logoutSuccessUrl("/"); // 6
}
</code></pre>

<p>La méthode d'authentification HTTP est précisée avec la méthode <code>httpBasic</code> (<code>1</code>). La racine, les fichiers CSS et javascript sont accessibles à tout le monde (<code>2</code>) tandis que toutes les autres requêtes nécessitent d'être authentifié (<code>3</code>).</p>

<p>L'URL de login est spécifiée via la méthode <code>loginPage</code> (<code>4</code>) et celle de logout via la méthode <code>logoutUrl</code> (<code>5</code>). Après la déconnexion, l'utilisateur est redirigé vers la racine (<code>6</code>).</p>

<p>Le code suivant illustre un formulaire de login et un formulaire de logout.</p>

<p>```html</p>

<!-- Formulaire de login -->


<p><form action="/login" method="post">
    <input type="text" name="username" />
    <input type="password" name="password" />
    <button type="submit">Login</button>
</form></p>

<!-- Formulaire de logout -->


<p><form action="/logout" method="post">
    <button type="submit">Logout</button>
</form>
```</p>

<h2>Conclusion</h2>

<p>La configuration de Spring Security en Java config est relativement simple et directe. Elle permet de contrôler et de centraliser les accès à toutes les URL de l'application. De plus, il est possible de définir très simplement les URL de login et de logout, Spring Security se chargeant des traitements des requêtes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Injections de dépendances avec Spring]]></title>
    <link href="http://nphumbert.github.io/blog/2015/06/14/injections-de-dependances-avec-spring/"/>
    <updated>2015-06-14T08:35:20+02:00</updated>
    <id>http://nphumbert.github.io/blog/2015/06/14/injections-de-dependances-avec-spring</id>
    <content type="html"><![CDATA[<p>Il existe plusieurs méthodes pour injecter une dépendance dans un objet Java :</p>

<ul>
<li>Injection sur un setter</li>
<li>Injection sur le constructeur</li>
<li>Injection directe sur la déclaration de l'attribut</li>
</ul>


<p>Cet article a pour objectif de définir ces différentes méthodes, de décrire leurs avantages et inconvénients et indiquer leurs cas d'utilisation.</p>

<!-- more -->


<p>Dans la plupart des applications Java d'entreprise, il y a des services ayant besoin de DAO pour accéder à la base de données. Le code suivant est une illustration de ce cas :</p>

<pre><code class="java">public class UserServiceImpl implements UserService {

   private UserDao userDao;

   @Override
   public User save(String name) {

      User user = new User(name);

      // NullPointerException car userDao n'est pas injecté.
      return userDao.save(user);
   }
}
</code></pre>

<p>Dans le cadre de cet article, l'annotation <code>@Autowired</code> de Spring sera utilisée pour injecter <code>userDao</code> dans le service.</p>

<h2>Injection sur un setter</h2>

<p>Il est possible de créer un setter et de l'annoter avec <code>@Autowired</code>. Spring va alors utiliser ce setter pour injecter <code>userDao</code> dans le service.</p>

<pre><code class="java">public class UserServiceImpl implements UserService {

   private UserDao userDao;

   @Autowired
   public void setUserDao(UserDao userDao) {
      this.userDao = userDao;
   }

   @Override
   public User save(String name) {

      User user = new User(name);

      // userDao est injecté via le setter annoté.
      return userDao.save(user);
   }
}
</code></pre>

<p>Cette méthode a pour avantage de rendre le <code>userDao</code> facilement injectable dans un test unitaire sans avoir à utiliser de framework particulier. Comme montré dans l'exemple ci-après :</p>

<pre><code class="java">public class UserServiceTest {

   @Test
   public void test_save() {

      // given
      String name = "Martin";
      UserService userService = new UserServiceImpl();
      userService.setUserDao(new FakeUserDaoImpl());

      // when
      User user = userService.save(name);

      // then
      assertThat(user.getName()).isEqualTo(name);

   }

   private class FakeUserDaoImpl implements UserDao {

      @Override
      public User save(User user) {
         return user;
      }
   }

}
</code></pre>

<p>Cependant, elle a pour inconvénient de rendre l'attribut <code>userDao</code> du service modifiable par tous les objets qui disposent d'une instance du service (ils peuvent donc même le rendre <code>null</code>).</p>

<h2>Injection sur le constructeur</h2>

<p>Dans cette méthode d'injection, le <code>userDao</code> est injecté dans le service via son constructeur annoté avec <code>@Autowired</code>.</p>

<pre><code class="java">public class UserServiceImpl implements UserService {

   private final UserDao userDao;

   @Autowired
   public UserServiceImpl(UserDao userDao) {
      this.userDao = userDao;
   }

   @Override
   public User save(String name) {

      User user = new User(name);

      // userDao est injecté via le constructeur annoté.
      return userDao.save(user);
   }
}
</code></pre>

<p>Comme la méthode d'injection à l'aide du setter, celle-ci permet de rendre le <code>userDao</code> facilement injectable dans un test unitaire.</p>

<pre><code class="java">public class UserServiceTest {

   @Test
   public void test_save() {

      // given
      String name = "Martin";
      UserService userService = new UserServiceImpl(new FakeUserDaoImpl());

      // when
      User user = userService.save(name);

      // then
      assertThat(user.getName()).isEqualTo(name);

   }

   private class FakeUserDaoImpl implements UserDao {

      @Override
      public User save(User user) {
         return user;
      }
   }

}
</code></pre>

<p>De plus, elle permet également d'assurer que le <code>userDao</code> ne sera jamais modifié. Il suffirait donc de mettre un contrôle de nullité dans le constructeur pour certifier qu'il ne sera jamais <code>null</code>.</p>

<p>Cependant, elle a pour inconvénient d'imposer la création de la dépendance dès l'instanciation du service même si elle n'est pas nécessaire.</p>

<h2>Injection sur la déclaration de l'attribut</h2>

<p>Cette méthode consiste à ajouter l'annotation <code>@Autowired</code> directement sur la déclaration de l'attribut.</p>

<pre><code class="java">public class UserServiceImpl implements UserService {

   @Autowired
   private UserDao userDao;

   @Override
   public User save(String name) {

      User user = new User(name);

      // userDao est injecté via l'annotation @Autowired.
      return userDao.save(user);
   }
}
</code></pre>

<p>Cette manière d'injecter a l'avantage d'être simple à utiliser.</p>

<p>Néanmoins, elle n'est pas conseillée car elle force à employer la réfléxion, ce qui la rend notamment plus compliquée à tester (utilisation obligatoire d'un framework de test).</p>

<pre><code class="java">public class UserServiceTest {

   @Test
   public void test_save() {

      // given
      String name = "Martin";
      UserService userService = new UserServiceImpl();
      UserDao fakeUserDao = new FakeUserDaoImpl();

      // Utilisation de la classe ReflectionTestUtils de Spring.
      ReflectionTestUtils.setField(userService, "userDao", fakeUserDao);

      // when
      User user = userService.save(name);

      // then
      assertThat(user.getName()).isEqualTo(name);

   }

   private class FakeUserDaoImpl implements UserDao {

      @Override
      public User save(User user) {
         return user;
      }
   }

}
</code></pre>

<p>De plus, elle rompt le principe de la programmation orientée objet qui stipule que les objets sont responsables de leurs attributs privés. En effet, l'attribut privé est ici manipulé directement par Spring ou le framework de test choisi.</p>

<h2>Conclusion</h2>

<p>L'injection d'un attribut d'un objet peut se faire de différentes manières.
L'injection par setter a pour avantage de rendre le code facilement testable. L'injection par constructeur a, en plus, l'avantage de pouvoir contrôler la nullité de l'attribut. Elle est donc conseilée pour les attributs obligatoires. Finalement, l'injection sur la déclaration de l'attribut est déconseilée car elle rend le code moins facilement testable et crée des dépendances cachées.</p>

<p>La testabilité du code est importante. En effet, un code non testable est signe d'un code qui sera difficile à comprendre et à maintenir.</p>
]]></content>
  </entry>
  
</feed>
