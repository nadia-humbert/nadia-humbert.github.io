<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: architecture | Nadia Humbert-Labeaumaz]]></title>
  <link href="https://nphumbert.github.io/blog/categories/architecture/atom.xml" rel="self"/>
  <link href="https://nphumbert.github.io/"/>
  <updated>2017-07-24T08:43:32+02:00</updated>
  <id>https://nphumbert.github.io/</id>
  <author>
    <name><![CDATA[Nadia Humbert-Labeaumaz]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Setup a Circuit Breaker with Hystrix, Feign Client and Spring Boot]]></title>
    <link href="https://nphumbert.github.io/blog/2017/07/23/setup-a-circuit-breaker-with-hystrix/"/>
    <updated>2017-07-23T13:33:38+02:00</updated>
    <id>https://nphumbert.github.io/blog/2017/07/23/setup-a-circuit-breaker-with-hystrix</id>
    <content type="html"><![CDATA[<p>In a microservices architecture, several things can go wrong. A middleware, the network or the service you want to contact can be down. In this world of uncertainty, you have to anticipate problems in order not to break the entire chain and throw an error to the end user when you could offer a partially degraded service instead.</p>

<p>The goal of this article is to show how to implement the circuit breaker pattern using Hystrix, Feign Client and Spring Boot.</p>

<!-- more -->


<h2>Feign Client Crash Course</h2>

<p><a href="https://github.com/OpenFeign/feign">Feign</a> is an HTTP client created by Netflix to make HTTP communications easier. It is integrated to Spring Boot with the <code>spring-cloud-starter-feign</code> starter.</p>

<p>To create a client to consume an HTTP service, an interface annotated with <code>@FeignClient</code> must be created. Endpoints can be declared in this interface using an API that is very close to the Spring MVC API. The <code>@EnableFeignClients</code> annotation must also be added to a Spring Configuration class.</p>

<pre><code class="java">@Configuration
@EnableFeignClients
public class FeignConfiguration {

}
</code></pre>

<pre><code class="java">@FeignClient(name = "videos", url = "http://localhost:9090/videos")
public interface VideoClient {

    @PostMapping(value = "/api/videos/suggest")
    List&lt;Suggestion&gt; suggest(@RequestBody ViewingHistory history);

}
</code></pre>

<p>An instance of <code>VideoClient</code> is automagically injected into the Spring application context and can be autowired and used throughout the application. Moreover, if the <code>videos</code> microservice is registred to the same discovery service as the current microservice, there is no need for an URL as it will be retrieved for you based on the <code>name</code>.</p>

<p>If the <code>videos</code> service, a middleware or the network happens to be down or overloaded, the <code>suggest</code> method will throw a <code>FeignException</code> that will be propagated throughout the stack if not caught.</p>

<h2>Create a Fallback Implementation</h2>

<p>Fortunately, Spring Cloud comes with a solution to this problem: a circuit breaker. In this article, we will use <a href="https://github.com/Netflix/Hystrix">Hystrix</a>. It is also created by Netflix and also integrated to Spring Boot using the <code>spring-cloud-starter-hystrix</code> starter.</p>

<p>The idea is to create an implementation of the <code>VideoClient</code> and mark it as the default behaviour if <code>videos</code> is unreachable or overloaded. Like a lot of other Spring features, it is enabled using an annotation: <code>@EnableCircuitBreaker</code>.</p>

<pre><code class="java">@Configuration
@EnableFeignClients
@EnableCircuitBreaker
public class FeignConfiguration {

}
</code></pre>

<pre><code class="java">@FeignClient(name = "videos", url = "http://localhost:9090/videos", fallback = VideoClientFallback.class)
public interface VideoClient {

    @PostMapping(value = "/api/videos/suggest")
    List&lt;Suggestion&gt; suggest(@RequestBody ViewingHistory history);

}
</code></pre>

<pre><code class="java">@Component
public class VideoClientFallback implements VideoClient {

    @Override
    public List&lt;Suggestion&gt; suggest(ViewingHistory history) {
      // Degraded service: no suggestion to offer
      return new ArrayList&lt;&gt;();
    }

}
</code></pre>

<p>A configuration property has to be added to the <code>application.yml</code> file of the Spring Boot application to tell Feign to enable Hystrix.</p>

<pre><code class="yml">feign:
    hystrix:
        enabled: true
</code></pre>

<p>Voila! Every time the remote service will be unavailable, the <code>suggest</code> method of the <code>VideoClientFallback</code> will be called and the end user will not get an error violently thrown at her.</p>

<h2>Keep Track of the Source Error</h2>

<p>With this setup, the fallback will be called regardless of the initial error that will be swallowed. If you want to retrieve this error and do something with it, you can use a <code>FallbackFactory</code>.</p>

<pre><code class="java">@FeignClient(name = "videos", url = "http://localhost:9090/videos", fallbackFactory = VideoClientFallbackFactory.class)
public interface VideoClient {

  @PostMapping(value = "/api/videos/suggest")
  List&lt;Suggestion&gt; suggest(@RequestBody ViewingHistory history);

}
</code></pre>

<pre><code class="java">@Component
public class VideoClientFallbackFactory implements FallbackFactory&lt;VideoClient&gt; {

    @Override
    public VideoClient create(Throwable throwable) {
        return new VideoClientFallback(throwable);
    }

}
</code></pre>

<pre><code class="java">public class VideoClientFallback implements VideoClient {

    private final Throwable cause;

    public VideoClientFallback(Throwable cause) {
      this.cause = cause;
    }

    @Override
    public List&lt;Suggestion&gt; suggest(ViewingHistory history) {
        if (cause instanceof FeignException &amp;&amp; ((FeignException) cause).status() == 404) {
            // Treat the HTTP 404 status
        }

        return new ArrayList&lt;&gt;();
    }

}
</code></pre>

<h2>Conclusion</h2>

<p>Microservices foster low coupling between components and resiliency. Hence, it would be sad to throw an error every time a service or a middleware is down. The circuit breaker pattern explained in this article allows you to ensure the continuity of service, even if it has to be offered in a degraded manner. As always, Spring Boot is a great help to setup this mechanism very easily.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Refactoring d'une application N-Tiers en utilisant le CQRS]]></title>
    <link href="https://nphumbert.github.io/blog/2016/06/26/refactoring-architecture-n-tiers-cqrs/"/>
    <updated>2016-06-26T18:14:40+02:00</updated>
    <id>https://nphumbert.github.io/blog/2016/06/26/refactoring-architecture-n-tiers-cqrs</id>
    <content type="html"><![CDATA[<p>CQRS, ou <em>Command Query Responsibility Segregation</em>, est une architecture où la partie <em>Command</em> (écriture) et la partie <em>Query</em> (lecture) du système sont séparées.</p>

<p>J'ai eu la chance d'assister récemment à une présentation de <a href="https://twitter.com/tjaskula">Tomasz Jaskula</a> nommée <a href="https://www.youtube.com/watch?v=5Sx_xO-eCE8">Recettes CQRS, pour bien cuisiner son architecture</a>. Je l'ai beaucoup appréciée, notamment car on voit les différentes étapes pour arriver à une architecture CQRS / Event Sourcing / DDD à partir d'une architecture N-Tiers &ldquo;classique&rdquo;.</p>

<p>L'objectif de cet article est de présenter ma compréhension et mon avis sur le CQRS en particulier.</p>

<!-- more -->


<h2>Mise en place</h2>

<p>Le passage d'une architecture N-Tiers à une architecture CQRS est relativement simple, comme montré ci-dessous.</p>

<p><img class="center" src="/images/cqrs.png"></p>

<p>Concrètement, je pense que cela consiste tout d'abord à identifier les requêtes associées à chacune des vues et à les regrouper dans des classes dédiées. Ces classes formeront la partie lecture de l'architecture.<br/>
Ensuite, les objets retournés par ces requêtes sont remplacés par des DTO qui ne contiennent plus que les informations nécessaires à la construction de la vue associée.<br/>
Finalement, le modèle d'écriture peut être débarrassé de toutes ses méthodes et propriétés transitoires, qui ne servaient seulement qu'à de la lecture.</p>

<p>Cette architecture apporte des avantages en termes de maintenabilité et de performances mais peut encore être améliorée.</p>

<h2>Conséquences</h2>

<h3>Augmentation de la maintenabilité</h3>

<p>L'application du CQRS simplifie grandement le modèle d'écriture. En effet, il arrive souvent que des propriétés <em>transient</em> soient calculées uniquement pour de l'affichage. Ces propriétés, ainsi que les méthodes associées, alourdissent le modèle et n'apportent pas de valeur pour les traitements métiers.</p>

<p>Les services, parfois très lourds, sont remplacés par des classes spécialisées, concises et cohérentes. Ceci permet donc de mieux respecter le <em>Single Responsibility Principle (SRP)</em> ainsi que l'<em>Interface Segregation Principle (ISP)</em>. De plus, il n'y aura plus de méthodes &ldquo;passe-plat&rdquo; dans les services car celles-ci seront directement implémentées dans les classes de lecture.</p>

<p>Finalement, l'ajout d'une nouvelle vue ne risque pas d'engendrer de régression car il s'agit simplement d'ajouter une nouvelle classe de lecture ainsi que le(s) DTO associé(s), sans modifier le reste.</p>

<h3>Amélioration des performances</h3>

<p>La séparation de la lecture et de l'écriture permet d'améliorer les performances du système. En effet, il est difficile d'optimiser à la fois la mise à jour et la lecture dans une base de données. Par exemple, l'ajout d'un index améliore grandement les performances à la lecture mais affecte sensiblement l'écriture.</p>

<p>Ces deux opérations pouvant être séparées dans deux bases différentes, il devient alors possible d'optimiser chacune des bases pour son utilisation particulière. De plus, les données de la base de lecture peuvent être dénormalisées, ce qui simplifie grandement les requêtes effectuées et peut les rendre bien plus efficaces.</p>

<h3>Pistes d'amélioration</h3>

<p>Selon moi, la principale difficulté du CQRS réside dans l'alimentation de la base de lecture à partir de la base d'écriture. Il est possible de la réaliser à l'aide d'un <em>batch</em> qui se lancera régulièrement. Cependant, l'application ne serait plus en temps réel.<br/>
Une alternative pourrait alors être d'écrire dans la base de lecture en même temps que dans la base d'écriture. Cette solution n'est pas idéale pour moi car elle ne supprime pas le couplage entre la lecture et l'écriture. De plus, si cette solution est implémentée via un mécanisme synchrone, il est impossible de paralléliser les traitements lorsque le système est très chargé, ce qui peut affecter nettement les performances.</p>

<p>La solution d'utiliser des événements asynchrones proposée par Tomasz me semble la plus adaptée pour résoudre ces problèmes. Comme il l'a indiqué, il faut néanmoins analyser le besoin et la stratégie d'entreprise ainsi que les ressources disponibles avant de se lancer dans la mise en place d'une telle architecture.</p>

<h2>Conclusion</h2>

<p>Le CQRS est une architecture simple à comprendre et à mettre en place. Elle permet d'augmenter la maintenabilité du code et d'améliorer les performances des vues. Je pense qu'elle peut être mise en place sur un projet (ou une de ses parties) dès que les vues se multiplient et que les services commencent à grossir.</p>
]]></content>
  </entry>
  
</feed>
